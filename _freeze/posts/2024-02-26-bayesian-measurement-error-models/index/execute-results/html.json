{
  "hash": "641ed63e049639f1a9bb8b451d4602e8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian measurement error models for longitudinal data\"\nsubtitle: | \n    TLDR: Why a good sandwich can solve so many of life's problems.\ndate: \"2024-02-26\"\ncategories: [measurement, Bayes, Stan]\n---\n\n\n\n\nRecently, I have been working with longitudinal biomarker data that looks something like this:\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nViral kinetics fans may notice this looks suspiciously like quantitative PCR results from an acute infection (it is), but for our purposes just note a few salient features:\n\n - a lower *limit of detection* for the instrument below which the data have been censored,\n - *classical* measurement error around a strong linear rise and fall (on the log scale),\n - the possibility for *false negatives*, due to insufficient or compromised sample collection, and *false positives*, due to sample contamination.\n\nI was interested in modeling the underlying biological phenomenon under a Bayesian paradigm, but this was both a slightly more complicated measurement error model than I had seen on the online forums and I had some questions about identifiability. So I thought it might make a nice blog post.\n\n## The generative model\nA few quick preliminaries, let $V_t$ be the true value of the outcome and $V^*_t$ the observed value both index by time $t$ which is centered at the highest observed value. We'll assume that, within individuals, the trajectory of the true value is well-approximated by the piece-wise exponential function\n$$\n\\log V_t = g(t; \\theta),\n$$\nwhere\n$$\ng(t; \\theta) = \\begin{cases}\n   \\dfrac{\\delta}{\\omega_p} (t - (t_p - \\omega_p)) & \\text{if } t \\leq t_p \\\\\n    \\delta - \\dfrac{\\delta}{\\omega_r} (t - t_p) & \\text{if } t > t_p,\n\\end{cases}\n$$\nThis is essentially a triangle on the log scale with parameters, $\\theta = (t_p, \\omega_p, \\delta_p, \\omega_r)$, governing the time of the peak ($t_p$), the peak height ($\\delta_p$), and the rise ($\\omega_p$) and fall times ($\\omega_r$). \n\nWe start by including classical measurement error and assume observed values are normal deviates (on the log scale) about the truth, i.e.\n$$\n\\begin{aligned}\n  \\log V^*_t &= \\log V_t + \\varepsilon \\\\\n  \\varepsilon &\\sim N(0, \\sigma)\n\\end{aligned}\n$$\nIn reality these errors are probably not homoskedastic, but for now this is a reasonable approximation. \n\nTo incorporate the lower limit of detection of the test, we assume values below the limit are censored such that the distribution function becomes\n$$\nf(\\log v^*_t ; \\log v_t, \\sigma) = \\begin{cases}\n\\dfrac{1}{\\sigma \\sqrt{2 \\pi}}\\exp\\left\\{-\\dfrac{1}{2}\\left(\\dfrac{\\log v^*_t-\\log v_t}{\\sigma}\\right)^2\\right\\} & \\text{if }v^*_t > lod \\\\\n\\Phi(\\log v^*_t) & \\text{if } v^* \\leq lod\n\\end{cases}\n$$\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function for the normal distribution. Here we assume that $lod$ is a known fixed value determined by the design of the test and therefore is not a parameter to be estimated from the data. For brevity, we define $N(\\log v_t, \\sigma)_{lod}$ to be the distribution with this distribution function.\n\nFinally, we include the possibility of false positive and false negatives by assuming the observed is actually drawn from a mixture\n$$\nf(\\log v^*_t ; \\log v_t, \\sigma) = \\begin{cases}\n p \\cdot \\dfrac{1}{\\sigma \\sqrt{2 \\pi}}\\exp\\left\\{-\\dfrac{1}{2}\\left(\\dfrac{\\log v^*_t-\\log v_t}{\\sigma}\\right)^2\\right\\} + (1-p)& \\text{if }v^*_t > lod \\\\\n\\Phi(\\log v^*_t) & \\text{if } v^* \\leq lod\n\\end{cases}\n$$\n$$\n\\log V^*_t \\sim \\lambda_1 N(\\log V_t, \\sigma)_{lod} + \\lambda_2 Exp(\\mu) + \\lambda_3 \\mathbb I(\\log V^*_t = lod)\n$$\nwhere $\\lambda_1$, $\\lambda_2$, and $\\lambda_3$ are the mixture probabilities denoting when the observed is drawn from the censored classical measurement error distribution ($\\lambda_1$) or is a false positive ($\\lambda_2$) or a false negative ($\\lambda_3$). We assume false positives are exponentially distributed with most of the mass near the limit of detection. False negatives will always have observed values at the lower limit of detection, so here we use the Dirac delta function, $\\delta_{V^*_t}(\\cdot)$, to represent a point mass at the limit. \n\n\n\n::: {.cell output.var='aft'}\n\n```{.cmdstan .cell-code}\nfunctions {\n  // This function calculates a piece-wise exponential function.\n  // t: The time variable.\n  // tp: The peak time.\n  // wp: The width of the peak.\n  // wr: The width of the right side of the function.\n  // dp: The depth of the peak.\n  real pefun(real t, real tp, real wp, real wr, real dp) {\n    if (t <= tp) {\n      return dp / wp * (t - (tp - wp)); // Viral load rises before peak\n    } else {\n      return dp - dp / wr * (t - tp); // Viral load falls after peak\n    }\n  }\n}\n\ndata {\n  int<lower=0> N;                   // sample size\n  vector[N] v_obs;                  // observed outcome\n  vector[N] t;                      // time\n  real lod;\n}\n\nparameters {\n  real dp;\n  real wp;\n  real wr;\n  real tp;\n  simplex[3] lambda;\n  real sigma;\n}\n\nmodel {\n   // PRIORS\n   beta_t ~ normal(0, 10);\n   beta_c ~ normal(0, 10);\n   alpha_t_raw ~ normal(0, 1);\n   alpha_c_raw ~ normal(0, 1);          \n\n   // LIKELIHOOD \n   for (n in 1:N) {\n     real v = pefun(n, tp, wp, wr, dp);\n     \n     if (v_obs[n] == lod) {\n       target += log_sum_exp(\n         log(lambda),\n         log1m(lambda) + normal_lcdf(lod | v, sigma)\n       )\n     } else {\n       target += log_sum_exp(\n         log(lambda[1]) + normal_lpdf(v_obs[n] | v, sigma), \n         log(lambda[2]) + exponential_lpdf(0 | mu),\n         log(lambda[3]) + dirac\n       )\n     }\n   }\n   y ~ normal(alpha + tau * a + beta_t * a + beta_c * (1 - a), sigma_t * a + sigma_c * (1 - a));\n}\n\n```\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}